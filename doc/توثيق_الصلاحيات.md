# توثيق الصلاحيات في نظام RasRas ERP

## نظرة عامة

يعتمد النظام على نموذج **صلاحيات ديناميكية** تُدار من لوحة التحكم دون تعديل الكود. مصدر الحقيقة الوحيد لظهور القوائم والوصول للمسارات هو جدول `rolepermissions` المرتبط بالأدوار.

---

## 1. هيكل البيانات

### الجداول ذات الصلة

| الجدول | الوصف |
|--------|--------|
| `roles` | الأدوار (مثل ADMIN، PM، SM، WHM) |
| `permissions` | تعريفات الصلاحيات (مثل SECTION_PROCUREMENT، SECTION_WAREHOUSE) |
| `rolepermissions` | ربط الأدوار بالصلاحيات (الجدول الوسيط) |
| `users` | المستخدمون، وكل مستخدم مرتبط بدور واحد |

### الكيانات (Backend)

- **Role**: الدور (مثل PM، SM، WHM)
- **Permission**: الصلاحية (مثلاً `SECTION_PROCUREMENT`)
- **RolePermission**: ربط الدور بالصلاحية مع حقل `IsAllowed`

---

## 2. صلاحيات الأقسام (SECTION_*)

صلاحيات الأقسام تحدد **ما يظهر في القائمة الجانبية** وما يمكن للمستخدم الوصول إليه من مسارات.

| كود الصلاحية | الوصف | المسارات المرتبطة |
|--------------|--------|-------------------|
| SECTION_MAIN | الرئيسية والاعتمادات | لوحة القيادة، الطلبات والاعتمادات |
| SECTION_USERS | المستخدمين | `/dashboard/users` |
| SECTION_EMPLOYEES | الموظفين | `/dashboard/employees` |
| SECTION_PROCUREMENT | المشتريات | `/dashboard/procurement/*` |
| SECTION_SALES | المبيعات | `/dashboard/sales/*` |
| SECTION_CRM | العملاء (CRM) | `/dashboard/crm/*` |
| SECTION_FINANCE | المالية والمحاسبة | `/dashboard/finance/*` |
| SECTION_WAREHOUSE | المخازن | `/dashboard/inventory/*` (عدا العمليات) |
| SECTION_OPERATIONS | العمليات | quality-parameters, price-lists, units, categories, items |
| SECTION_SYSTEM | إعدادات النظام | `/dashboard/settings/*` |

**ملاحظة:** المسارات `/dashboard` و `/dashboard/approvals` و `/dashboard/profile` متاحة لجميع من سجّل دخوله ولا تحتاج صلاحية قسم.

### Override Access — GM و ADMIN

| الدور | الوصف |
|------|-------|
| **ADMIN** | Override access دائمًا — صلاحيات كاملة على جميع الأقسام والإعدادات. |
| **GM (المدير العام)** | Override access دائمًا — وصول لكل الأقسام للرقابة والاعتماد، دون تقييد بصلاحية قسم واحد. |

**مهم:** عند إضافة صلاحيات أو حماية endpoints، ضع في الاعتبار أن GM و ADMIN لهم وصول تلقائي عبر `hasAnyRole('ADMIN','GM')` في `@PreAuthorize` أو عبر تعيين كل SECTION_* لهم في لوحة التحكم. تجنّب الالتباس لاحقًا بتوثيق ذلك صراحة.

### ثوابت أكواد الأدوار (Frontend)

لتجنّب الاعتماد على Strings مبعثرة، استخدم الثوابت المركزية في `web/frontend/src/constants/roleCodes.ts`:

```typescript
import { ROLE_CODES } from '../constants/roleCodes';
// ROLE_CODES.FINANCE_MANAGER = "FM"
// ROLE_CODES.ACCOUNTANT = "ACC"
// ROLE_CODES.WAREHOUSE_KEEPER = "WHM"
// إلخ
```

---

## 3. تدفق الصلاحيات من الباكند إلى الواجهة

### 3.1 عند تسجيل الدخول

```
المستخدم يسجل الدخول
       ↓
AuthenticationManager يتحقق من الهوية
       ↓
UserDetailsService يحمّل المستخدم عبر findByUsernameWithPermissions
       ↓
UserPrincipal.create(user) يُنشئ الصلاحيات من role.rolePermissions
       ↓
صلاحيات الدور (التي تبدأ بـ SECTION_ وغيرها) تُضاف كـ GrantedAuthority
       ↓
AuthService.login يجمع الصلاحيات (باستثناء ROLE_*) ويضعها في LoginResponse.permissions
       ↓
الواجهة تحفظ user في localStorage (يشمل permissions)
```

### 3.2 تفاصيل تقنية

- **UserRepository**: استعلام `findByUsernameWithPermissions` يحمّل المستخدم مع دورهِ وصلاحيات الدور (`rolePermissions`).
- **UserPrincipal**: يحوّل `RolePermission` (حيث `isAllowed = true`) إلى `SimpleGrantedAuthority` بأكواد الصلاحيات.
- **AuthService**: يجمع من `userPrincipal.getAuthorities()` كل ما لا يبدأ بـ `ROLE_` ويرسله كقائمة `permissions` في استجابة تسجيل الدخول.

---

## 4. استخدام الصلاحيات في الواجهة (Frontend)

### 4.1 تخزين بيانات المستخدم

بعد تسجيل الدخول تُحفظ في `localStorage`:

```javascript
localStorage.setItem('user', JSON.stringify({
  userId, employeeId, username, roleCode, roleName,
  fullNameAr,
  permissions: ['SECTION_MAIN', 'SECTION_PROCUREMENT', ...]
}));
```

لا تعتمد على `localStorage` فقط — استخدم `refreshUserPermissions()` من `authService` لتحديث الصلاحيات من الخادم (راجع القسم 8).

### 4.2 القائمة الجانبية (Sidebar)

في `DashboardLayout.tsx`:

- كل عنصر قائمة له حقل `requiredPermission` اختياري (مثل `SECTION_PROCUREMENT`).
- إذا لم يكن للعنصر `requiredPermission` → يظهر للجميع.
- إذا كان له `requiredPermission` → يظهر فقط إن كان لدى المستخدم هذه الصلاحية في `user.permissions`.

```javascript
const filteredNavItems = navItems.filter(item => {
  if (!item.requiredPermission) return true;
  return userPermissions.includes(item.requiredPermission);
});
```

لا يوجد رجوع للأدوار: التصفية تعتمد على الصلاحيات فقط.

### 4.3 حماية المسارات

في `permissionUtils.ts`، الدالة `canAccessPath(path, userRole, userPermissions)`:

- تحدد الصلاحية المطلوبة للمسار عبر `getRequiredPermissionForPath`.
- إذا لم يحتج المسار صلاحية (مثل `/dashboard`، `/dashboard/approvals`) → يُسمح بالدخول.
- إذا احتاج صلاحية → يُسمح فقط إن كانت موجودة في `userPermissions`.

```javascript
export function canAccessPath(path, _userRole, userPermissions) {
  const required = getRequiredPermissionForPath(path);
  if (!required) return true;
  return userPermissions?.includes(required) ?? false;
}
```

`DashboardLayout` يستخدم `canAccessPath` عند تغيير المسار؛ إن لم يكن للمستخدم الصلاحية يُوجّه إلى `/dashboard`.

---

## 5. إدارة الصلاحيات من لوحة التحكم

### 5.1 صفحة الأدوار والصلاحيات

- المسار: `/dashboard/settings/roles`
- الصلاحية المطلوبة: `SECTION_SYSTEM`
- تُعرَض الأدوار مع إمكانية تعيين/إلغاء صلاحيات الأقسام لكل دور.

### 5.2 تعيين الصلاحيات للأدوار

- `RoleService.assignPermissions(roleId, permissionIds)` يستبدل صلاحيات الدور بقائمة الصلاحيات المحددة.
- التغييرات تنعكس عند **تسجيل الدخول التالي** للمستخدم، لأن الصلاحيات تُحمّل من الخادم في استجابة تسجيل الدخول.

---

## 6. التهيئة الافتراضية (DataSeeder)

عند التشغيل الأول يُنفّذ `DataSeeder`:

1. **seedSectionPermissions**: إنشاء صلاحيات الأقسام وتعيينها لـ ADMIN.
2. **seedDefaultRoleSectionPermissions**: تعيين صلاحيات الأقسام للأدوار الافتراضية:

| الدور | صلاحيات الأقسام |
|-------|-----------------|
| PM, BUYER | SECTION_MAIN, SECTION_PROCUREMENT |
| SM | SECTION_MAIN, SECTION_SALES, SECTION_CRM |
| WHM | SECTION_MAIN, SECTION_WAREHOUSE |
| GM | جميع الأقسام |
| FM, ACC | SECTION_MAIN |

دور **WHM (أمين المخزن)** يُنشأ في `seedRoles` إن لم يكن موجوداً.

---

## 7. ملخص التدفق

```
┌─────────────────────────────────────────────────────────────────┐
│  لوحة التحكم: الأدوار والصلاحيات                                 │
│  المدير يختار الدور ويعيّن له SECTION_* المناسبة                  │
└──────────────────────────┬──────────────────────────────────────┘
                           │ rolepermissions
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│  تسجيل الدخول                                                    │
│  UserPrincipal يقرأ role.rolePermissions                         │
│  AuthService يرسل permissions في LoginResponse                   │
└──────────────────────────┬──────────────────────────────────────┘
                           │ user.permissions
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│  الواجهة الأمامية                                                │
│  • السايد بار: يظهر العنصر إن وُجدت requiredPermission في permissions │
│  • المسارات: canAccessPath يتحقق من وجود الصلاحية المطلوبة       │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. تحديث الصلاحيات دون إعادة تسجيل الدخول

لتجنّب الاعتماد على `localStorage` فقط (لأن الصلاحيات قد تتغيّر من لوحة الأدوار دون علم المستخدم الحالي):

- **API**: `GET /auth/me` يُرجع المستخدم الحالي مع `permissions` من الخادم.
- **الواجهة**: الدالة `refreshUserPermissions()` في `authService.ts` تستدعي `/auth/me` وتحدّث `localStorage.user`.
- **متى تُستدعى**: `DashboardLayout` يستدعيها عند التحميل الأوّل للوحة التحكم، فتُحدَّث الصلاحيات من الخادم تلقائياً.

```typescript
// استدعاء يدوي عند الحاجة (مثلاً بعد تغيير الدور من لوحة الأدوار)
import { refreshUserPermissions } from '../../services/authService';
await refreshUserPermissions();
```

---

## 9. ملاحظات مهمة

1. **تحديث الصلاحيات**: يُحدَّث تلقائياً عند فتح لوحة التحكم عبر `refreshUserPermissions`. التغييرات الفورية (مثلاً بعد تعديل الأدوار) ستُنعكس عند تنقّل المستخدم أو إعادة تحميل الصفحة.
2. **حماية الباكند**: التحقق في الواجهة يمنع الوصول للمسارات والقوائم. ينبغي أن تكون واجهات الباكند محمية أيضاً حسب الدور والصلاحيات.
3. **مصدر واحد للحقيقة**: ظهور الأقسام والوصول للمسارات يعتمد على صلاحيات الأدوار في قاعدة البيانات فقط، دون قوائم أدوار ثابتة في الكود.
4. **Action-level permissions** (مثل "إنشاء"، "تعديل"، "حذف") ستُضاف كمرحلة قادمة — حالياً الاعتماد على صلاحيات الأقسام.
